package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.41

import (
	"context"
	"fmt"
	"time"

	"github.com/Gekuro/democrator/api/graph/model"
	"github.com/Gekuro/democrator/api/store"
	"github.com/Gekuro/democrator/api/utils"
)

const DEFAULT_POLL_DURATION = time.Hour * 2

// CreatePoll is the resolver for the createPoll field.
func (r *mutationResolver) CreatePoll(ctx context.Context, options model.OptionsInput) (*model.CreatePollResponse, error) {
	if len(options.Names) == 1 || len(options.Names) > 15 {
		return nil, fmt.Errorf("error: there should be between 2 and 15 options")
	}

	id, err := utils.GetUnusedPollId(r.DB)
	if err != nil {
		return nil, fmt.Errorf("internal server error")
	}

	poll := &store.Poll{Id: id, ExpiresAt: time.Now().Add(DEFAULT_POLL_DURATION)}
	opts := []*store.Option{}

	for _, n := range options.Names {
		opts = append(opts, &store.Option{PollId: id, Name: n, Votes: 0})
	}
	
	result := r.DB.Create(&poll)
	if result.Error != nil || result.RowsAffected != 1 { // TODO log this
		return nil, fmt.Errorf("internal server error")
	}

	result = r.DB.Create(opts)
	if result.Error != nil || result.RowsAffected < 2 { // TODO log this
		return nil, fmt.Errorf("internal server error")
	}

	return &model.CreatePollResponse{ID: &id}, nil
}

// Vote is the resolver for the vote field.
func (r *mutationResolver) Vote(ctx context.Context, vote model.VoteInput) (*model.VoteResponse, error) {
	var option store.Option
	result := r.DB.Where("poll_id = ? AND name = ?", vote.ID, vote.Option).
		Find(&option)
	
	if result.RowsAffected != 1 { // TODO log this
		return nil, fmt.Errorf("internal server error")
	}

	option.Votes++

	result = r.DB.Save(&option)
	if result.RowsAffected != 1 { // TODO log this
		return nil, fmt.Errorf("internal server error")
	}

	return &model.VoteResponse{Message: "success"}, nil
}

// WatchPoll is the resolver for the watchPoll field.
func (r *subscriptionResolver) WatchPoll(ctx context.Context, pollID string) (<-chan []*model.Option, error) {
	var poll store.Poll

	result := r.DB.First(&poll).
		Where("id = ?", pollID)

	if result.RowsAffected != 1 {
		return nil, fmt.Errorf("no such poll")
	}

	return r.Streamer.Subscribe(pollID), nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
