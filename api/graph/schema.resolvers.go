package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.41

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/Gekuro/democrator/api/graph/model"
	"github.com/Gekuro/democrator/api/store"
	"github.com/Gekuro/democrator/api/utils"
)

// CreatePoll is the resolver for the createPoll field.
func (r *mutationResolver) CreatePoll(ctx context.Context, options model.OptionsInput) (*model.CreatePollResponse, error) {
	const DEFAULT_POLL_DURATION = time.Hour * 2

	if len(options.Names) == 1 || len(options.Names) > 15 {
		return nil, fmt.Errorf("there should be between 2 and 15 options")
	}

	id, err := utils.GetUnusedPollId(r.DB)
	if err != nil {
		return nil, fmt.Errorf("internal server error")
	}

	poll := &store.Poll{Id: id, ExpiresAt: time.Now().Add(DEFAULT_POLL_DURATION)}
	opts := []*store.Option{}

	for _, n := range options.Names {
		opts = append(opts, &store.Option{PollId: id, Name: n, Votes: 0})
	}

	result := r.DB.Create(&poll)
	if result.Error != nil || result.RowsAffected != 1 {
		log.Printf("error saving to database: %s", result.Error)
		return nil, fmt.Errorf("internal server error")
	}

	result = r.DB.Create(opts)
	if result.Error != nil || result.RowsAffected < 2 {
		log.Printf("error saving to database: %s", result.Error)
		return nil, fmt.Errorf("internal server error")
	}

	return &model.CreatePollResponse{ID: &id}, nil
}

// Vote is the resolver for the vote field.
func (r *mutationResolver) Vote(ctx context.Context, vote model.VoteInput) (*model.VoteResponse, error) {
	expired, err := store.IsPollExpired(r.DB, vote.ID)
	if err != nil {
		return &model.VoteResponse{Message: "no such poll"}, nil
	} else if expired {
		return &model.VoteResponse{Message: "poll is closed"}, nil
	}

	var option store.Option
	result := r.DB.Find(&option, "poll_id = ? AND name = ?", vote.ID, vote.Option)

	if result.RowsAffected != 1 {
		return &model.VoteResponse{Message: "no such option"}, nil
	}

	option.Votes++

	result = r.DB.Save(&option)
	if result.RowsAffected != 1 {
		log.Printf("error saving to database: %s", result.Error)
		return nil, fmt.Errorf("internal server error")
	}

	return &model.VoteResponse{Message: "success"}, nil
}

// GetPoll is the resolver for the getPoll field.
func (r *queryResolver) GetPoll(ctx context.Context, id string) (*model.Poll, error) {
	var poll store.Poll

	result := r.DB.First(&poll, "id = ?", id)

	if result.RowsAffected != 1 {
		return nil, fmt.Errorf("no such poll")
	}

	var opts []store.Option
	var modelOpts []*model.Option

	result = r.DB.Find(&opts, "poll_id = ?", id)

	if result.RowsAffected < 2 || result.RowsAffected > 15 {
		log.Printf("corrupted database: poll.id=%s has an invalid amount of options (%v)", id, result.RowsAffected)
		return nil, fmt.Errorf("could not load poll options")
	}

	for _, option := range opts {
		modelOpts = append(modelOpts, &model.Option{Name: option.Name, Votes: option.Votes})
	}

	return &model.Poll{ID: poll.Id, Options: modelOpts, ExpiresAt: int(poll.ExpiresAt.Unix())}, nil
}

// WatchPoll is the resolver for the watchPoll field.
func (r *subscriptionResolver) WatchPoll(ctx context.Context, id string) (<-chan []*model.Option, error) {
	var poll store.Poll

	result := r.DB.First(&poll, "id = ?", id)

	if result.RowsAffected != 1 {
		return nil, fmt.Errorf("no such poll")
	}

	return r.PubSub.Subscribe(id), nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
